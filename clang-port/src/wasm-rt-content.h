#include <string>

inline static std::string wasm_rt_content =
"/*\n"
" * Copyright 2018 WebAssembly Community Group participants\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     http://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"#ifndef WASM_RT_H_\n"
"#define WASM_RT_H_\n"
"\n"
"#include <setjmp.h>\n"
"#include <stdbool.h>\n"
"#include <stdint.h>\n"
"#include <string.h>\n"
"\n"
"//#include <experimental/bits/simd.h>\n"
"#include <immintrin.h>\n"
"\n"
"#ifdef __cplusplus\n"
"extern \"C\"\n"
"{\n"
"#endif\n"
"\n"
"#ifndef __has_builtin\n"
"#define __has_builtin( x ) 0 // Compatibility with non-clang compilers.\n"
"#endif\n"
"\n"
"#if __has_builtin( __builtin_expect )\n"
"#define UNLIKELY( x ) __builtin_expect( !!( x ), 0 )\n"
"#define LIKELY( x ) __builtin_expect( !!( x ), 1 )\n"
"#else\n"
"#define UNLIKELY( x ) ( x )\n"
"#define LIKELY( x ) ( x )\n"
"#endif\n"
"\n"
"#if __has_builtin( __builtin_memcpy )\n"
"#define wasm_rt_memcpy __builtin_memcpy\n"
"#else\n"
"#define wasm_rt_memcpy memcpy\n"
"#endif\n"
"\n"
"/** Enable memory checking via a signal handler via the following definition:\n"
" *\n"
" * #define WASM_RT_MEMCHECK_SIGNAL_HANDLER 1\n"
" *\n"
" * This is usually 10%-25% faster, but requires OS-specific support.\n"
" * */\n"
"\n"
"/** Check whether the signal handler is supported at all. */\n"
"#if ( defined( __linux__ ) || defined( __unix__ ) || defined( __APPLE__ ) ) && defined( __WORDSIZE )               \\\n"
"  && __WORDSIZE == 64\n"
"\n"
"/* If the signal handler is supported, then use it by default. */\n"
"#ifndef WASM_RT_MEMCHECK_SIGNAL_HANDLER\n"
"#define WASM_RT_MEMCHECK_SIGNAL_HANDLER 1\n"
"#endif\n"
"\n"
"#if WASM_RT_MEMCHECK_SIGNAL_HANDLER\n"
"#define WASM_RT_MEMCHECK_SIGNAL_HANDLER_POSIX 1\n"
"#endif\n"
"\n"
"#else\n"
"\n"
"/* The signal handler is not supported, error out if the user was trying to\n"
" * enable it. */\n"
"#if WASM_RT_MEMCHECK_SIGNAL_HANDLER\n"
"#error \"Signal handler is not supported for this OS/Architecture!\"\n"
"#endif\n"
"\n"
"#define WASM_RT_MEMCHECK_SIGNAL_HANDLER 0\n"
"#define WASM_RT_MEMCHECK_SIGNAL_HANDLER_POSIX 0\n"
"\n"
"/** When the signal handler is not used, stack depth is limited explicitly.\n"
" * The maximum stack depth before trapping can be configured by defining\n"
" * this symbol before including wasm-rt when building the generated c files,\n"
" * for example:\n"
" *\n"
" * ```\n"
" *   cc -c -DWASM_RT_MAX_CALL_STACK_DEPTH=100 my_module.c -o my_module.o\n"
" * ```\n"
" * */\n"
"#ifndef WASM_RT_MAX_CALL_STACK_DEPTH\n"
"#define WASM_RT_MAX_CALL_STACK_DEPTH 500\n"
"#endif\n"
"\n"
"/** Current call stack depth. */\n"
"extern uint32_t wasm_rt_call_stack_depth;\n"
"\n"
"#endif\n"
"\n"
"#if defined( _MSC_VER )\n"
"#define WASM_RT_NO_RETURN __declspec( noreturn )\n"
"#else\n"
"#define WASM_RT_NO_RETURN __attribute__( ( noreturn ) )\n"
"#endif\n"
"\n"
"#if defined( __APPLE__ ) && WASM_RT_MEMCHECK_SIGNAL_HANDLER_POSIX\n"
"#define WASM_RT_MERGED_OOB_AND_EXHAUSTION_TRAPS 1\n"
"#else\n"
"#define WASM_RT_MERGED_OOB_AND_EXHAUSTION_TRAPS 0\n"
"#endif\n"
"\n"
"  /** Reason a trap occurred. Provide this to `wasm_rt_trap`. */\n"
"  typedef enum\n"
"  {\n"
"    WASM_RT_TRAP_NONE,               /** No error. */\n"
"    WASM_RT_TRAP_OOB,                /** Out-of-bounds access in linear memory or a table. */\n"
"    WASM_RT_TRAP_INT_OVERFLOW,       /** Integer overflow on divide or truncation. */\n"
"    WASM_RT_TRAP_DIV_BY_ZERO,        /** Integer divide by zero. */\n"
"    WASM_RT_TRAP_INVALID_CONVERSION, /** Conversion from NaN to integer. */\n"
"    WASM_RT_TRAP_UNREACHABLE,        /** Unreachable instruction executed. */\n"
"    WASM_RT_TRAP_CALL_INDIRECT,      /** Invalid call_indirect, for any reason. */\n"
"    WASM_RT_TRAP_UNCAUGHT_EXCEPTION, /* Exception thrown and not caught */\n"
"#if WASM_RT_MERGED_OOB_AND_EXHAUSTION_TRAPS\n"
"    WASM_RT_TRAP_EXHAUSTION = WASM_RT_TRAP_OOB,\n"
"#else\n"
"  WASM_RT_TRAP_EXHAUSTION, /** Call stack exhausted. */\n"
"#endif\n"
"  } wasm_rt_trap_t;\n"
"\n"
"  /** Value types. Used to define function signatures. */\n"
"  typedef enum\n"
"  {\n"
"    WASM_RT_I32,\n"
"    WASM_RT_I64,\n"
"    WASM_RT_F32,\n"
"    WASM_RT_F64,\n"
"    WASM_RT_FUNCREF,\n"
"    WASM_RT_EXTERNREF,\n"
"  } wasm_rt_type_t;\n"
"\n"
"  /** A generic function pointer type, both for Wasm functions (`code`)\n"
"   * and host functions (`hostcode`). All function pointers are stored\n"
"   * in this canonical form, but must be cast to their proper signature\n"
"   * to call. */\n"
"  typedef void ( *wasm_rt_function_ptr_t )( void );\n"
"\n"
"  /** A function instance (the runtime representation of a function).\n"
"   * These can be stored in tables of type funcref, or used as values. */\n"
"  typedef struct\n"
"  {\n"
"    /** The index as returned from `wasm_rt_register_func_type`. */\n"
"    uint32_t func_type;\n"
"    /** The function. */\n"
"    wasm_rt_function_ptr_t func;\n"
"    /** The module instance of the originating module. */\n"
"    void* module_instance;\n"
"  } wasm_rt_funcref_t;\n"
"\n"
"  /** An external reference. These are opaque have meaning only to the host. */\n"
"  typedef __m256i wasm_rt_externref_t;\n"
"\n"
"  /** Default (null) value of an externref */\n"
"  static const wasm_rt_externref_t wasm_rt_externref_null_value = { 0, 0, 0, 0 };\n"
"\n"
"  /** A Memory object. */\n"
"  typedef struct\n"
"  {\n"
"    wasm_rt_externref_t ref;\n"
"    bool read_only;\n"
"    /** The linear memory data, with a byte length of `size`. */\n"
"    uint8_t* data;\n"
"    /** The current and maximum page count for this Memory object. If there is no\n"
"     * maximum, `max_pages` is 0xffffffffu (i.e. UINT32_MAX). */\n"
"    uint32_t pages, max_pages;\n"
"    /** The current size of the linear memory, in bytes. */\n"
"    uint32_t size;\n"
"  } wasm_rt_memory_t;\n"
"\n"
"  /** A Table of type funcref. */\n"
"  typedef struct\n"
"  {\n"
"    /** The table element data, with an element count of `size`. */\n"
"    wasm_rt_funcref_t* data;\n"
"    /** The maximum element count of this Table object. If there is no maximum,\n"
"     * `max_size` is 0xffffffffu (i.e. UINT32_MAX). */\n"
"    uint32_t max_size;\n"
"    /** The current element count of the table. */\n"
"    uint32_t size;\n"
"  } wasm_rt_funcref_table_t;\n"
"\n"
"  /** A Table of type externref. */\n"
"  typedef struct\n"
"  {\n"
"    bool read_only;\n"
"    /** The table element data, with an element count of `size`. */\n"
"    wasm_rt_externref_t* data;\n"
"    /** The maximum element count of this Table object. If there is no maximum,\n"
"     * `max_size` is 0xffffffffu (i.e. UINT32_MAX). */\n"
"    uint32_t max_size;\n"
"    /** The current element count of the table. */\n"
"    uint32_t size;\n"
"  } wasm_rt_externref_table_t;\n"
"\n"
"  /** Initialize the runtime. */\n"
"  void wasm_rt_init( void );\n"
"\n"
"  /** Is the runtime initialized? */\n"
"  bool wasm_rt_is_initialized( void );\n"
"\n"
"  /** Free the runtime's state. */\n"
"  void wasm_rt_free( void );\n"
"\n"
"  /** Stop execution immediately and jump back to the call to `wasm_rt_impl_try`.\n"
"   *  The result of `wasm_rt_impl_try` will be the provided trap reason.\n"
"   *\n"
"   *  This is typically called by the generated code, and not the embedder. */\n"
"  WASM_RT_NO_RETURN void wasm_rt_trap( wasm_rt_trap_t );\n"
"\n"
"  /**\n"
"   * Return a human readable error string based on a trap type.\n"
"   */\n"
"  const char* wasm_rt_strerror( wasm_rt_trap_t trap );\n"
"\n"
"  /** Register a function type with the given signature. The returned function\n"
"   * index is guaranteed to be the same for all calls with the same signature.\n"
"   * The following varargs must all be of type `wasm_rt_type_t`, first the\n"
"   * params` and then the `results`.\n"
"   *\n"
"   *  ```\n"
"   *    // Register (func (param i32 f32) (result i64)).\n"
"   *    wasm_rt_register_func_type(2, 1, WASM_RT_I32, WASM_RT_F32, WASM_RT_I64);\n"
"   *    => returns 1\n"
"   *\n"
"   *    // Register (func (result i64)).\n"
"   *    wasm_rt_register_func_type(0, 1, WASM_RT_I32);\n"
"   *    => returns 2\n"
"   *\n"
"   *    // Register (func (param i32 f32) (result i64)) again.\n"
"   *    wasm_rt_register_func_type(2, 1, WASM_RT_I32, WASM_RT_F32, WASM_RT_I64);\n"
"   *    => returns 1\n"
"   *  ``` */\n"
"  extern uint32_t wasm_rt_register_func_type( uint32_t params, uint32_t results, ... );\n"
"\n"
"  /**\n"
"   * Register a tag with the given size. Returns the tag.\n"
"   */\n"
"  uint32_t wasm_rt_register_tag( uint32_t size );\n"
"\n"
"  /**\n"
"   * Set the active exception to given tag, size, and contents.\n"
"   */\n"
"  void wasm_rt_load_exception( uint32_t tag, uint32_t size, const void* values );\n"
"\n"
"  /**\n"
"   * Throw the active exception.\n"
"   */\n"
"  WASM_RT_NO_RETURN void wasm_rt_throw( void );\n"
"\n"
"  /**\n"
"   * Stores the current unwind target (for use if an exception is thrown), and\n"
"   * returns the previous one.\n"
"   */\n"
"  jmp_buf* wasm_rt_push_unwind_target( jmp_buf* target );\n"
"\n"
"  /**\n"
"   * Restore the unwind target at the end of a try-catch block.\n"
"   */\n"
"  void wasm_rt_pop_unwind_target( jmp_buf* target );\n"
"\n"
"  /**\n"
"   * Tag of the active exception.\n"
"   */\n"
"  uint32_t wasm_rt_exception_tag( void );\n"
"\n"
"  /**\n"
"   * Size of the active exception.\n"
"   */\n"
"  uint32_t wasm_rt_exception_size( void );\n"
"\n"
"  /**\n"
"   * Contents of the active exception.\n"
"   */\n"
"  void* wasm_rt_exception( void );\n"
"\n"
"#if WASM_RT_MEMCHECK_SIGNAL_HANDLER_POSIX\n"
"#define WASM_RT_SETJMP( buf ) sigsetjmp( buf, 1 )\n"
"#else\n"
"#define WASM_RT_SETJMP( buf ) setjmp( buf )\n"
"#endif\n"
"\n"
"#define wasm_rt_try( target ) WASM_RT_SETJMP( target )\n"
"\n"
"  /** Initialize a Memory object with an initial page size of `initial_pages` and\n"
"   * a maximum page size of `max_pages`.\n"
"   *\n"
"   *  ```\n"
"   *    wasm_rt_memory_t my_memory;\n"
"   *    // 1 initial page (65536 bytes), and a maximum of 2 pages.\n"
"   *    wasm_rt_allocate_memory(&my_memory, 1, 2);\n"
"   *  ``` */\n"
"  extern void wasm_rt_allocate_memory( wasm_rt_memory_t*, uint32_t initial_pages, uint32_t max_pages );\n"
"\n"
"  extern void wasm_rt_allocate_memory_sw_checked( wasm_rt_memory_t*, uint32_t initial_pages, uint32_t max_pages );\n"
"\n"
"  /** Grow a Memory object by `pages`, and return the previous page count. If\n"
"   * this new page count is greater than the maximum page count, the grow fails\n"
"   * and 0xffffffffu (UINT32_MAX) is returned instead.\n"
"   *\n"
"   *  ```\n"
"   *    wasm_rt_memory_t my_memory;\n"
"   *    ...\n"
"   *    // Grow memory by 10 pages.\n"
"   *    uint32_t old_page_size = wasm_rt_grow_memory(&my_memory, 10);\n"
"   *    if (old_page_size == UINT32_MAX) {\n"
"   *      // Failed to grow memory.\n"
"   *    }\n"
"   *  ``` */\n"
"  extern uint32_t wasm_rt_grow_memory( wasm_rt_memory_t*, uint32_t pages );\n"
"\n"
"  extern uint32_t wasm_rt_grow_memory_sw_checked( wasm_rt_memory_t*, uint32_t pages );\n"
"\n"
"  /**\n"
"   * Free a Memory object.\n"
"   */\n"
"  extern void wasm_rt_free_memory( wasm_rt_memory_t* );\n"
"\n"
"  extern void wasm_rt_free_memory_sw_checked( wasm_rt_memory_t* );\n"
"\n"
"  /** Initialize a funcref Table object with an element count of `elements` and a\n"
"   * maximum size of `max_elements`.\n"
"   *\n"
"   *  ```\n"
"   *    wasm_rt_funcref_table_t my_table;\n"
"   *    // 5 elements and a maximum of 10 elements.\n"
"   *    wasm_rt_allocate_funcref_table(&my_table, 5, 10);\n"
"   *  ``` */\n"
"  extern void wasm_rt_allocate_funcref_table( wasm_rt_funcref_table_t*, uint32_t elements, uint32_t max_elements );\n"
"\n"
"  /**\n"
"   * Free a funcref Table object.\n"
"   */\n"
"  extern void wasm_rt_free_funcref_table( wasm_rt_funcref_table_t* );\n"
"\n"
"  /** Initialize an externref Table object with an element count of `elements` and\n"
"   * a maximum size of `max_elements`. Usage as per\n"
"   * wasm_rt_allocate_funcref_table. */\n"
"  extern void wasm_rt_allocate_externref_table( wasm_rt_externref_table_t*,\n"
"                                                uint32_t elements,\n"
"                                                uint32_t max_elements );\n"
"\n"
"  /**\n"
"   * Free an externref Table object.\n"
"   */\n"
"  extern void wasm_rt_free_externref_table( wasm_rt_externref_table_t* );\n"
"\n"
"  /** Grow a Table object by `delta` elements (giving the new elements the value\n"
"   * `init`), and return the previous element count. If this new element count is\n"
"   * greater than the maximum element count, the grow fails and 0xffffffffu\n"
"   * (UINT32_MAX) is returned instead.  ``` */\n"
"  extern uint32_t wasm_rt_grow_funcref_table( wasm_rt_funcref_table_t*, uint32_t delta, wasm_rt_funcref_t init );\n"
"  extern uint32_t wasm_rt_grow_externref_table( wasm_rt_externref_table_t*,\n"
"                                                uint32_t delta,\n"
"                                                wasm_rt_externref_t init );\n"
"\n"
"#ifdef _WIN32\n"
"  float wasm_rt_truncf( float x );\n"
"  double wasm_rt_trunc( double x );\n"
"  float wasm_rt_nearbyintf( float x );\n"
"  double wasm_rt_nearbyint( double x );\n"
"  float wasm_rt_fabsf( float x );\n"
"  double wasm_rt_fabs( double x );\n"
"#else\n"
"#define wasm_rt_truncf( x ) truncf( x )\n"
"#define wasm_rt_trunc( x ) trunc( x )\n"
"#define wasm_rt_nearbyintf( x ) nearbyintf( x )\n"
"#define wasm_rt_nearbyint( x ) nearbyint( x )\n"
"#define wasm_rt_fabsf( x ) fabsf( x )\n"
"#define wasm_rt_fabs( x ) fabs( x )\n"
"#endif\n"
"\n"
"#ifdef __cplusplus\n"
"}\n"
"#endif\n"
"\n"
"#endif /* WASM_RT_H_ */\n"
;
